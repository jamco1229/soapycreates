---
import Layout from '../layouts/Layout.astro';
import { getCollection } from 'astro:content';
import '../styles/ceramicist.css';

const mugs = (await getCollection('mugs')).sort(
	(a, b) => a.data.date.valueOf() - b.data.date.valueOf()
);
---

<Layout title="Sophie Banks | Soapy Creates">
	<main class="ceramicist-page is-loading">
		<div class="ceramicist-mugs">
			{mugs.map((mug, index) => (
				<div
					class="ceramicist-mug-container"
					data-index={index}
					data-title={mug.data.title}
					data-date={mug.data.date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}
					data-image={mug.data.image}
					role="button"
					tabindex="0"
				>
					<img src={mug.data.image} alt={mug.data.title} class="ceramicist-mug" loading="eager" />
					<span class="ceramicist-mug-shadow"></span>
				</div>
			))}
		</div>

		<div class="ceramicist-center">
			<img
				src="/soapy wordmark.svg"
				alt="SOAPY"
				class="ceramicist-wordmark"
				loading="eager"
			/>
			<p class="ceramicist-subtitle">artist</p>
		</div>
	</main>

	<!-- Notecard Modal -->
	<div class="notecard-overlay" id="notecard-overlay" aria-hidden="true">
		<div class="notecard" role="dialog" aria-modal="true" aria-labelledby="notecard-title">
			<svg class="notecard-texture" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
				<filter id="paper-texture">
					<feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" result="noise" />
					<feDiffuseLighting in="noise" lighting-color="#f5f2eb" surfaceScale="1.5">
						<feDistantLight azimuth="45" elevation="60" />
					</feDiffuseLighting>
				</filter>
				<rect width="100%" height="100%" filter="url(#paper-texture)" />
			</svg>
			<div class="notecard-image-container">
				<img class="notecard-image" id="notecard-image" src="" alt="" />
			</div>
			<div class="notecard-content">
				<h2 class="notecard-title" id="notecard-title"></h2>
				<p class="notecard-date" id="notecard-date"></p>
			</div>
			<div class="notecard-tape notecard-tape-left"></div>
			<div class="notecard-tape notecard-tape-right"></div>
		</div>
		<span class="notecard-arrow notecard-arrow-prev" aria-label="Previous">&larr;</span>
		<span class="notecard-arrow notecard-arrow-next" aria-label="Next">&rarr;</span>
	</div>
</Layout>

<script type="module">
	const containers = Array.from(
		document.querySelectorAll('.ceramicist-mug-container')
	);

	function isTooClose(pos1, pos2, minDistance) {
		const dx = pos1.left - pos2.left;
		const dy = pos1.top - pos2.top;
		return Math.sqrt(dx * dx + dy * dy) < minDistance;
	}

	function generateRandomPositions(count) {
		const positions = [];
		const baseMinDistance = 14;

		for (let i = 0; i < count; i++) {
			let top = 0;
			let left = 0;
			let attempts = 0;
			let validPosition = false;

			do {
				top = Math.random() * 80 + 5;
				left = Math.random() * 80 + 5;
				attempts += 1;

				const inCenter = top > 34 && top < 66 && left > 28 && left < 72;
				const tooCloseToOther = positions.some((pos) => {
					const minDistance = baseMinDistance + (pos.size - 140) * 0.05;
					return isTooClose({ top, left }, pos, minDistance);
				});

				validPosition = !inCenter && !tooCloseToOther;
			} while (!validPosition && attempts < 200);

			const size = 155 + Math.random() * 45;
			if (!validPosition) {
				const angle = (i / count) * Math.PI * 2;
				top = 50 + Math.sin(angle) * 30;
				left = 50 + Math.cos(angle) * 35;
			}
			positions.push({ top, left, size });
		}

		return positions;
	}

	const positions = generateRandomPositions(containers.length);
	containers.forEach((container, index) => {
		const { top, left, size } = positions[index];
		container.style.top = `${top}%`;
		container.style.left = `${left}%`;
		container.style.width = `${size}px`;
		container.style.animationDelay = `${0.25 + index * 0.08}s`;
	});

	requestAnimationFrame(() => {
		const page = document.querySelector('.ceramicist-page');
		if (page) {
			page.classList.remove('is-loading');
			page.classList.add('is-ready');
		}
	});

	// Notecard Modal Logic
	const overlay = document.getElementById('notecard-overlay');
	const notecard = overlay.querySelector('.notecard');
	const notecardImage = document.getElementById('notecard-image');
	const notecardTitle = document.getElementById('notecard-title');
	const notecardDate = document.getElementById('notecard-date');
	const prevArrow = overlay.querySelector('.notecard-arrow-prev');
	const nextArrow = overlay.querySelector('.notecard-arrow-next');

	let currentIndex = 0;
	let isAnimating = false;

	function showMug(index, direction = null, fromDrag = false) {
		const container = containers[index];
		const title = container.dataset.title;
		const date = container.dataset.date;
		const image = container.dataset.image;

		if (direction && !isAnimating) {
			isAnimating = true;
			const slideIn = direction === 'next' ? 'slide-in-right' : 'slide-in-left';

			if (fromDrag) {
				// Skip slide-out, user already dragged it away
				notecardImage.src = image;
				notecardImage.alt = title;
				notecardTitle.textContent = title;
				notecardDate.textContent = date;

				notecard.offsetHeight;
				notecard.classList.add(slideIn);

				setTimeout(() => {
					notecard.classList.remove(slideIn);
					isAnimating = false;
				}, 280);
			} else {
				// Full animation for arrow/keyboard nav
				const slideOut = direction === 'next' ? 'slide-out-left' : 'slide-out-right';

				notecard.offsetHeight;
				notecard.classList.add(slideOut);

				setTimeout(() => {
					notecardImage.src = image;
					notecardImage.alt = title;
					notecardTitle.textContent = title;
					notecardDate.textContent = date;

					notecard.classList.remove(slideOut);
					notecard.offsetHeight;
					notecard.classList.add(slideIn);

					setTimeout(() => {
						notecard.classList.remove(slideIn);
						isAnimating = false;
					}, 280);
				}, 220);
			}
		} else {
			notecardImage.src = image;
			notecardImage.alt = title;
			notecardTitle.textContent = title;
			notecardDate.textContent = date;
		}

		currentIndex = index;
	}

	function openNotecard(container) {
		currentIndex = parseInt(container.dataset.index);
		showMug(currentIndex);
		overlay.classList.add('is-visible');
		overlay.setAttribute('aria-hidden', 'false');
	}

	function closeNotecard() {
		overlay.classList.remove('is-visible');
		overlay.setAttribute('aria-hidden', 'true');
	}

	function goToPrev() {
		if (isAnimating) return;
		const newIndex = (currentIndex - 1 + containers.length) % containers.length;
		showMug(newIndex, 'prev');
	}

	function goToNext() {
		if (isAnimating) return;
		const newIndex = (currentIndex + 1) % containers.length;
		showMug(newIndex, 'next');
	}

	containers.forEach((container) => {
		container.addEventListener('click', () => openNotecard(container));
		container.addEventListener('keydown', (e) => {
			if (e.key === 'Enter' || e.key === ' ') {
				e.preventDefault();
				openNotecard(container);
			}
		});
	});

	prevArrow.addEventListener('click', (e) => {
		e.stopPropagation();
		goToPrev();
	});

	nextArrow.addEventListener('click', (e) => {
		e.stopPropagation();
		goToNext();
	});

	overlay.addEventListener('click', (e) => {
		if (e.target === overlay) closeNotecard();
	});

	document.addEventListener('keydown', (e) => {
		if (!overlay.classList.contains('is-visible')) return;
		if (e.key === 'Escape') closeNotecard();
		if (e.key === 'ArrowLeft') goToPrev();
		if (e.key === 'ArrowRight') goToNext();
	});

	// Swipe support for mobile
	let touchStartX = 0;
	let touchEndX = 0;

	notecard.addEventListener('touchstart', (e) => {
		touchStartX = e.changedTouches[0].screenX;
	}, { passive: true });

	notecard.addEventListener('touchend', (e) => {
		touchEndX = e.changedTouches[0].screenX;
		const diff = touchStartX - touchEndX;
		if (Math.abs(diff) > 50) {
			if (diff > 0) {
				const newIndex = (currentIndex + 1) % containers.length;
				showMug(newIndex, 'next', true);
			} else {
				const newIndex = (currentIndex - 1 + containers.length) % containers.length;
				showMug(newIndex, 'prev', true);
			}
		}
	}, { passive: true });

	// Drag support for desktop
	let isDragging = false;
	let dragStartX = 0;
	let dragCurrentX = 0;
	let hasDragged = false;

	notecard.addEventListener('mousedown', (e) => {
		if (isAnimating) return;
		isDragging = true;
		hasDragged = false;
		dragStartX = e.clientX;
		dragCurrentX = e.clientX;
		notecard.style.cursor = 'grabbing';
		notecard.style.transition = 'none';
	});

	document.addEventListener('mousemove', (e) => {
		if (!isDragging) return;
		dragCurrentX = e.clientX;
		const diff = dragCurrentX - dragStartX;

		if (Math.abs(diff) > 5) hasDragged = true;

		const rotation = diff * 0.05;
		const clampedRotation = Math.max(-10, Math.min(10, rotation));
		notecard.style.transform = `perspective(800px) translateX(${diff * 0.4}px) rotateY(${clampedRotation}deg) rotateZ(${-1 + diff * 0.02}deg)`;
		notecard.style.opacity = 1 - Math.abs(diff) * 0.002;
	});

	document.addEventListener('mouseup', () => {
		if (!isDragging) return;
		isDragging = false;
		notecard.style.cursor = '';
		notecard.style.transition = '';
		notecard.style.transform = '';
		notecard.style.opacity = '';

		const diff = dragStartX - dragCurrentX;
		if (Math.abs(diff) > 60) {
			if (diff > 0) {
				const newIndex = (currentIndex + 1) % containers.length;
				showMug(newIndex, 'next', true);
			} else {
				const newIndex = (currentIndex - 1 + containers.length) % containers.length;
				showMug(newIndex, 'prev', true);
			}
		}
	});

	// Prevent click after drag
	notecard.addEventListener('click', (e) => {
		if (hasDragged) {
			e.stopPropagation();
			hasDragged = false;
		}
	}, true);
</script>
