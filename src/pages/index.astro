---
import Layout from "../layouts/Layout.astro";
import { getCollection } from "astro:content";
import "../styles/ceramicist.css";

const mugs = (await getCollection("mugs")).sort(
    (a, b) => a.data.date.valueOf() - b.data.date.valueOf(),
);
const mugEntries = await Promise.all(
    mugs.map(async (mug) => {
        const { Content } = await mug.render();
        return { ...mug, Content };
    }),
);
const bioEntry = (await getCollection("bio"))[0];
const bioContent = bioEntry ? (await bioEntry.render()).Content : null;
const showGrid = false;
---

<Layout title="Sophie Banks | Soapy Creates">
    <main class={`ceramicist-page is-loading ${showGrid ? "show-grid" : ""}`}>
        {showGrid ? <div class="ceramicist-grid" aria-hidden="true" /> : null}
        <div class="ceramicist-mugs">
            {
                mugEntries.map((mug, index) => (
                    <div
                        class="ceramicist-mug-container"
                        data-index={index}
                        data-title={mug.data.title}
                        data-date={mug.data.date.toLocaleDateString("en-US", {
                            year: "numeric",
                            month: "long",
                            day: "numeric",
                        })}
                        data-image={mug.data.image}
                        data-bg-image={mug.data.bgImage}
                        role="button"
                        tabindex="0"
                    >
                        <img
                            src={mug.data.image}
                            alt=""
                            class="ceramicist-mug-shadow-img"
                            loading="eager"
                            aria-hidden="true"
                        />
                        <img
                            src={mug.data.image}
                            alt={mug.data.title}
                            class="ceramicist-mug"
                            loading="eager"
                        />
                    </div>
                ))
            }
        </div>

        <div class="ceramicist-center">
            <button
                class="ceramicist-wordmark-button"
                type="button"
                aria-label="Open bio"
            >
                <img
                    src="/soapy wordmark.svg"
                    alt="SOAPY"
                    class="ceramicist-wordmark"
                    loading="eager"
                />
            </button>
        </div>
        <div class="ceramicist-chrome">
            <button class="ceramicist-chrome-tl" type="button">
                Sophie Banks
            </button>
            <p class="ceramicist-chrome-tr">ARTIST</p>
            <p class="ceramicist-chrome-bl">Norwich, NORFOLK UK</p>
            <button class="ceramicist-shuffle" id="shuffle-btn">Shuffle</button>
            <a
                href="https://instagram.com/soapycreates"
                target="_blank"
                rel="noopener"
                class="ceramicist-chrome-br"
            >
                @SOAPYCREATES
            </a>
        </div>
    </main>

    <!-- Notecard Modal -->
    <div class="notecard-overlay" id="notecard-overlay" aria-hidden="true">
        <div
            class="notecard"
            role="dialog"
            aria-modal="true"
            aria-labelledby="notecard-title"
        >
            <svg
                class="notecard-texture"
                viewBox="0 0 200 200"
                xmlns="http://www.w3.org/2000/svg"
            >
                <filter id="paper-texture">
                    <feTurbulence
                        type="fractalNoise"
                        baseFrequency="0.9"
                        numOctaves="4"
                        result="noise"></feTurbulence>
                    <feDiffuseLighting
                        in="noise"
                        lighting-color="#f5f2eb"
                        surfaceScale="1.5"
                    >
                        <feDistantLight azimuth="45" elevation="60"
                        ></feDistantLight>
                    </feDiffuseLighting>
                </filter>
                <rect width="100%" height="100%" filter="url(#paper-texture)"
                ></rect>
            </svg>
            <div class="notecard-image-container">
                <div class="notecard-paperclip" aria-hidden="true"></div>
                <img class="notecard-image" id="notecard-image" src="" alt="" />
            </div>
            <div class="notecard-content">
                <h2 class="notecard-title" id="notecard-title"></h2>
                <p class="notecard-date" id="notecard-date"></p>
                <div class="notecard-description">
                    <div
                        class="notecard-description-body"
                        id="notecard-description"
                    >
                    </div>
                    <button
                        class="notecard-show-more"
                        id="notecard-show-more"
                        type="button"
                    >
                        Show more
                    </button>
                </div>
            </div>
            <div class="notecard-tape notecard-tape-left"></div>
            <div class="notecard-tape notecard-tape-right"></div>
        </div>
        <span class="notecard-arrow notecard-arrow-prev" aria-label="Previous"
            >&larr;</span
        >
        <span class="notecard-arrow notecard-arrow-next" aria-label="Next"
            >&rarr;</span
        >
    </div>
    <div class="notecard-descriptions" aria-hidden="true">
        {
            mugEntries.map((mug, index) => (
                <div class="notecard-description-source" data-index={index}>
                    <mug.Content />
                </div>
            ))
        }
    </div>
    <div class="bio-overlay" id="bio-overlay" aria-hidden="true">
        <div class="notecard bio-notecard" role="dialog" aria-modal="true">
            <div class="notecard-image-container bio-image-container">
                <div class="notecard-paperclip" aria-hidden="true"></div>
                <img
                    src="/pp-2.png"
                    alt=""
                    class="notecard-image bio-image-back"
                />
                <img
                    src="/pp.png"
                    alt=""
                    class="notecard-image bio-image-front"
                />
            </div>
            <div class="notecard-content">
                <p class="bio-title">Sophie Banks</p>
                <div class="bio-content">
                    {bioContent ? <bioContent /> : null}
                </div>
            </div>
        </div>
    </div>
</Layout>

<script type="module">
    const containers = Array.from(
        document.querySelectorAll(".ceramicist-mug-container"),
    );

    function generatePositions(count) {
        const isMobile = window.innerWidth <= 768;

        // Grid configuration: cells like a chessboard
        // Mobile: 3 cols × 5 rows, center cell (7) reserved for wordmark
        // Desktop: 5 cols × 4 rows, middle column cells (7, 12) reserved
        const config = isMobile ? {
            cols: 3,
            rows: 5,
            padding: { top: 8, bottom: 8, left: 5, right: 5 },
            excludedCells: [7], // center cell (row 2, col 1)
            jitterPercent: 0.20,
            sizes: { 0: [120, 140], 1: [135, 155], 2: [145, 165], 3: [150, 170], 4: [155, 180] }
        } : {
            cols: 5,
            rows: 4,
            padding: { top: 10, bottom: 10, left: 5, right: 5 },
            excludedCells: [7, 12], // middle column, rows 1-2
            jitterPercent: 0.15,
            sizes: { 0: [160, 190], 1: [190, 220], 2: [210, 240], 3: [220, 260] }
        };

        // Calculate cell dimensions
        const availableWidth = 100 - config.padding.left - config.padding.right;
        const availableHeight = 100 - config.padding.top - config.padding.bottom;
        const cellWidth = availableWidth / config.cols;
        const cellHeight = availableHeight / config.rows;

        // Build list of available cells
        const availableCells = [];
        for (let i = 0; i < config.cols * config.rows; i++) {
            if (!config.excludedCells.includes(i)) availableCells.push(i);
        }

        // Helper to check if two cells are adjacent (including diagonals)
        function areAdjacent(cellA, cellB) {
            const rowA = Math.floor(cellA / config.cols);
            const colA = cellA % config.cols;
            const rowB = Math.floor(cellB / config.cols);
            const colB = cellB % config.cols;
            return Math.abs(rowA - rowB) <= 1 && Math.abs(colA - colB) <= 1;
        }

        // Select cells preferring non-adjacent placement
        const selectedCells = [];
        const remainingCells = [...availableCells].sort(() => Math.random() - 0.5);

        for (let i = 0; i < count; i++) {
            // Find cells not adjacent to any already selected
            const nonAdjacent = remainingCells.filter(cell =>
                !selectedCells.some(selected => areAdjacent(cell, selected))
            );

            // Prefer non-adjacent, fallback to any remaining
            const pool = nonAdjacent.length > 0 ? nonAdjacent : remainingCells;
            const chosenIndex = Math.floor(Math.random() * pool.length);
            const chosen = pool[chosenIndex];

            selectedCells.push(chosen);
            remainingCells.splice(remainingCells.indexOf(chosen), 1);

            // If we've used all cells, refill for overflow
            if (remainingCells.length === 0) {
                remainingCells.push(...availableCells.sort(() => Math.random() - 0.5));
            }
        }

        // Generate positions
        const positions = [];
        for (let i = 0; i < count; i++) {
            const cellIndex = selectedCells[i];
            const col = cellIndex % config.cols;
            const row = Math.floor(cellIndex / config.cols);

            // Cell center in percentages
            const centerX = config.padding.left + (col + 0.5) * cellWidth;
            const centerY = config.padding.top + (row + 0.5) * cellHeight;

            // Apply jitter within cell bounds
            const jitterX = (Math.random() - 0.5) * cellWidth * config.jitterPercent;
            const jitterY = (Math.random() - 0.5) * cellHeight * config.jitterPercent;

            // Size based on row (larger toward bottom for depth)
            const sizeRange = config.sizes[row];
            const size = sizeRange[0] + Math.random() * (sizeRange[1] - sizeRange[0]);

            positions.push({
                top: centerY + jitterY,
                left: centerX + jitterX,
                size
            });
        }

        return positions;
    }

    function applyPositions(animated = false) {
        const positions = generatePositions(containers.length);
        containers.forEach((container, index) => {
            const { top, left, size } = positions[index];
            if (animated) {
                container.style.transition =
                    "top 0.4s ease, left 0.4s ease, width 0.4s ease";
            }
            container.style.top = `${top}%`;
            container.style.left = `${left}%`;
            container.style.width = `${size}px`;
            if (!animated) {
                container.style.animationDelay = `${0.3 + index * 0.08}s`;
            }
        });
        if (animated) {
            setTimeout(() => {
                containers.forEach((container) => {
                    container.style.transition = "";
                });
            }, 400);
        }
    }

    applyPositions();

    // Shuffle button
    const shuffleBtn = document.getElementById("shuffle-btn");
    let danceInterval = null;
    let holdTimeout = null;
    let isDancing = false;

    function startDancing() {
        isDancing = true;
        containers.forEach((container) => {
            container.classList.add("is-dancing");
        });
    }

    function stopDancing() {
        isDancing = false;
        containers.forEach((container) => {
            container.classList.remove("is-dancing");
        });
    }

    shuffleBtn.addEventListener("mousedown", () => {
        holdTimeout = setTimeout(() => {
            startDancing();
        }, 5000);
    });

    shuffleBtn.addEventListener("mouseup", () => {
        clearTimeout(holdTimeout);
        if (isDancing) {
            stopDancing();
            applyPositions(true);
        } else {
            applyPositions(true);
        }
    });

    shuffleBtn.addEventListener("mouseleave", () => {
        clearTimeout(holdTimeout);
        if (isDancing) {
            stopDancing();
        }
    });

    // Touch support for dance
    shuffleBtn.addEventListener("touchstart", (e) => {
        e.preventDefault();
        holdTimeout = setTimeout(() => {
            startDancing();
        }, 5000);
    });

    shuffleBtn.addEventListener("touchend", () => {
        clearTimeout(holdTimeout);
        if (isDancing) {
            stopDancing();
            applyPositions(true);
        } else {
            applyPositions(true);
        }
    });

    // Wait for all mug images to load before animating in
    const mugImages = Array.from(document.querySelectorAll(".ceramicist-mug"));
    const imagePromises = mugImages.map((img) => {
        if (img.complete) return Promise.resolve();
        return new Promise((resolve) => {
            img.onload = resolve;
            img.onerror = resolve;
        });
    });

    Promise.all(imagePromises).then(() => {
        requestAnimationFrame(() => {
            const page = document.querySelector(".ceramicist-page");
            if (page) {
                page.classList.remove("is-loading");
                page.classList.add("is-ready");
            }
        });

        // Preload all bgImages for smooth modal transitions
        containers.forEach((container) => {
            const bgImage = container.dataset.bgImage;
            if (bgImage) {
                const img = new Image();
                img.src = bgImage;
            }
        });
    });

    // Notecard Modal Logic
    const overlay = document.getElementById("notecard-overlay");
    const notecard = overlay.querySelector(".notecard");
    const notecardImage = document.getElementById("notecard-image");
    const notecardTitle = document.getElementById("notecard-title");
    const notecardDate = document.getElementById("notecard-date");
    const notecardDescription = document.getElementById("notecard-description");
    const notecardShowMore = document.getElementById("notecard-show-more");
    const prevArrow = overlay.querySelector(".notecard-arrow-prev");
    const nextArrow = overlay.querySelector(".notecard-arrow-next");
    const descriptionSources = Array.from(
        document.querySelectorAll(".notecard-description-source"),
    );
    const bioOverlay = document.getElementById("bio-overlay");
    const bioCard = bioOverlay?.querySelector(".bio-card");
    const bioTriggers = Array.from(
        document.querySelectorAll(
            ".ceramicist-wordmark-button, .ceramicist-chrome-tl",
        ),
    );

    let currentIndex = 0;
    let isAnimating = false;

    function updateDescription(index) {
        const source = descriptionSources.find(
            (item) => item.dataset.index === String(index),
        );
        notecardDescription.innerHTML = source ? source.innerHTML : "";
        notecardDescription.classList.remove("is-expanded");
        notecardShowMore.textContent = "Show more";

        requestAnimationFrame(() => {
            const hasOverflow =
                notecardDescription.scrollHeight >
                notecardDescription.clientHeight + 1;
            notecardShowMore.style.display = hasOverflow
                ? "inline-flex"
                : "none";
        });
    }

    function showMug(index, direction = null, fromDrag = false) {
        const container = containers[index];
        const title = container.dataset.title;
        const date = container.dataset.date;
        const bgImage = container.dataset.bgImage;

        if (direction && !isAnimating) {
            isAnimating = true;
            const slideIn =
                direction === "next" ? "slide-in-right" : "slide-in-left";

            if (fromDrag) {
                // Skip slide-out, user already dragged it away
                notecardImage.src = bgImage;
                notecardImage.alt = title;
                notecardTitle.textContent = title;
                notecardDate.textContent = date;
                updateDescription(index);

                notecard.offsetHeight;
                notecard.classList.add(slideIn);

                setTimeout(() => {
                    notecard.classList.remove(slideIn);
                    isAnimating = false;
                }, 280);
            } else {
                // Full animation for arrow/keyboard nav
                const slideOut =
                    direction === "next" ? "slide-out-left" : "slide-out-right";

                notecard.offsetHeight;
                notecard.classList.add(slideOut);

                setTimeout(() => {
                    notecardImage.src = bgImage;
                    notecardImage.alt = title;
                    notecardTitle.textContent = title;
                    notecardDate.textContent = date;
                    updateDescription(index);

                    notecard.classList.remove(slideOut);
                    notecard.offsetHeight;
                    notecard.classList.add(slideIn);

                    setTimeout(() => {
                        notecard.classList.remove(slideIn);
                        isAnimating = false;
                    }, 280);
                }, 220);
            }
        } else {
            notecardImage.src = bgImage;
            notecardImage.alt = title;
            notecardTitle.textContent = title;
            notecardDate.textContent = date;
            updateDescription(index);
        }

        currentIndex = index;
    }

    function openNotecard(container) {
        currentIndex = parseInt(container.dataset.index);
        showMug(currentIndex);
        overlay.classList.add("is-visible");
        overlay.setAttribute("aria-hidden", "false");
    }

    function closeNotecard() {
        overlay.classList.remove("is-visible");
        overlay.setAttribute("aria-hidden", "true");
    }

    function openBio() {
        if (!bioOverlay) return;
        bioOverlay.classList.add("is-visible");
        bioOverlay.setAttribute("aria-hidden", "false");
    }

    function closeBio() {
        if (!bioOverlay) return;
        bioOverlay.classList.remove("is-visible");
        bioOverlay.setAttribute("aria-hidden", "true");
    }

    function goToPrev() {
        if (isAnimating) return;
        const newIndex =
            (currentIndex - 1 + containers.length) % containers.length;
        showMug(newIndex, "prev");
    }

    function goToNext() {
        if (isAnimating) return;
        const newIndex = (currentIndex + 1) % containers.length;
        showMug(newIndex, "next");
    }

    containers.forEach((container) => {
        container.addEventListener("click", () => openNotecard(container));
        container.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                openNotecard(container);
            }
        });
    });

    bioTriggers.forEach((trigger) => {
        trigger.addEventListener("click", (e) => {
            e.stopPropagation();
            openBio();
        });
    });

    prevArrow.addEventListener("click", (e) => {
        e.stopPropagation();
        goToPrev();
    });

    nextArrow.addEventListener("click", (e) => {
        e.stopPropagation();
        goToNext();
    });

    notecardShowMore.addEventListener("click", (e) => {
        e.stopPropagation();
        const isExpanded = notecardDescription.classList.toggle("is-expanded");
        notecardShowMore.textContent = isExpanded ? "Show less" : "Show more";
        if (!isExpanded) {
            requestAnimationFrame(() => {
                const hasOverflow =
                    notecardDescription.scrollHeight >
                    notecardDescription.clientHeight + 1;
                notecardShowMore.style.display = hasOverflow
                    ? "inline-flex"
                    : "none";
            });
        } else {
            notecardShowMore.style.display = "inline-flex";
        }
    });

    overlay.addEventListener("click", (e) => {
        if (e.target === overlay) closeNotecard();
    });

    if (bioOverlay && bioCard) {
        bioOverlay.addEventListener("click", (e) => {
            if (e.target === bioOverlay) closeBio();
        });
    }

    document.addEventListener("keydown", (e) => {
        if (!overlay.classList.contains("is-visible")) return;
        if (e.key === "Escape") closeNotecard();
        if (e.key === "ArrowLeft") goToPrev();
        if (e.key === "ArrowRight") goToNext();
    });

    document.addEventListener("keydown", (e) => {
        if (!bioOverlay || !bioOverlay.classList.contains("is-visible")) return;
        if (e.key === "Escape") closeBio();
    });

    // Swipe support for mobile - card follows finger
    let touchStartX = 0;
    let currentTouchX = 0;
    let isSwiping = false;

    notecard.addEventListener(
        "touchstart",
        (e) => {
            if (isAnimating) return;
            touchStartX = e.changedTouches[0].screenX;
            currentTouchX = touchStartX;
            isSwiping = true;
            notecard.style.transition = "none";
        },
        { passive: true },
    );

    notecard.addEventListener(
        "touchmove",
        (e) => {
            if (!isSwiping) return;
            currentTouchX = e.changedTouches[0].screenX;
            const diff = currentTouchX - touchStartX;
            // Move card with finger, with slight resistance
            const resistance = 0.6;
            notecard.style.transform = `translateX(${diff * resistance}px) rotate(${diff * 0.02}deg)`;
        },
        { passive: true },
    );

    notecard.addEventListener(
        "touchend",
        (e) => {
            if (!isSwiping) return;
            isSwiping = false;
            const diff = currentTouchX - touchStartX;
            const threshold = 60;

            if (Math.abs(diff) > threshold) {
                // Swipe left (diff < 0) = next, swipe right (diff > 0) = prev
                const goingNext = diff < 0;
                const newIndex = goingNext
                    ? (currentIndex + 1) % containers.length
                    : (currentIndex - 1 + containers.length) %
                      containers.length;

                // Fly current card off in swipe direction
                const flyOutX = goingNext
                    ? -window.innerWidth
                    : window.innerWidth;
                notecard.style.transition = "transform 0.2s ease-in";
                notecard.style.transform = `translateX(${flyOutX}px)`;

                setTimeout(() => {
                    // Position new card on opposite side
                    const enterFromX = goingNext
                        ? window.innerWidth
                        : -window.innerWidth;
                    notecard.style.transition = "none";
                    notecard.style.transform = `translateX(${enterFromX}px)`;

                    showMug(newIndex, goingNext ? "next" : "prev", true);

                    // Slide new card to center
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            notecard.style.transition =
                                "transform 0.2s ease-out";
                            notecard.style.transform = "translateX(0)";
                        });
                    });
                }, 200);
            } else {
                // Snap back
                notecard.style.transition = "transform 0.2s ease-out";
                notecard.style.transform = "translateX(0)";
            }
        },
        { passive: true },
    );

    // Drag support for desktop
    let isDragging = false;
    let dragStartX = 0;
    let dragCurrentX = 0;
    let hasDragged = false;

    notecard.addEventListener("mousedown", (e) => {
        if (isAnimating) return;
        isDragging = true;
        hasDragged = false;
        dragStartX = e.clientX;
        dragCurrentX = e.clientX;
        notecard.style.cursor = "grabbing";
        notecard.style.transition = "none";
    });

    document.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        dragCurrentX = e.clientX;
        const diff = dragCurrentX - dragStartX;

        if (Math.abs(diff) > 5) hasDragged = true;

        const resistance = 0.6;
        notecard.style.transform = `translateX(${diff * resistance}px) rotate(${diff * 0.02}deg)`;
    });

    document.addEventListener("mouseup", () => {
        if (!isDragging) return;
        isDragging = false;
        notecard.style.cursor = "";

        const diff = dragCurrentX - dragStartX;
        const threshold = 60;

        if (Math.abs(diff) > threshold) {
            // Drag left (diff < 0) = next, drag right (diff > 0) = prev
            const goingNext = diff < 0;
            const newIndex = goingNext
                ? (currentIndex + 1) % containers.length
                : (currentIndex - 1 + containers.length) % containers.length;

            // Fly current card off in drag direction
            const flyOutX = goingNext ? -window.innerWidth : window.innerWidth;
            notecard.style.transition = "transform 0.2s ease-in";
            notecard.style.transform = `translateX(${flyOutX}px)`;

            setTimeout(() => {
                // Position new card on opposite side
                const enterFromX = goingNext
                    ? window.innerWidth
                    : -window.innerWidth;
                notecard.style.transition = "none";
                notecard.style.transform = `translateX(${enterFromX}px)`;

                showMug(newIndex, goingNext ? "next" : "prev", true);

                // Slide new card to center
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        notecard.style.transition = "transform 0.2s ease-out";
                        notecard.style.transform = "translateX(0)";
                    });
                });
            }, 200);
        } else {
            // Snap back
            notecard.style.transition = "transform 0.2s ease-out";
            notecard.style.transform = "translateX(0)";
        }
    });

    // Prevent click after drag
    notecard.addEventListener(
        "click",
        (e) => {
            if (hasDragged) {
                e.stopPropagation();
                hasDragged = false;
            }
        },
        true,
    );
</script>
