---
import Layout from "../layouts/Layout.astro";
import { getCollection } from "astro:content";
import "../styles/sophie.css";

const mugs = (await getCollection("mugs")).sort(
    (a, b) => a.data.date.valueOf() - b.data.date.valueOf(),
);
const mugEntries = await Promise.all(
    mugs.map(async (mug) => {
        const { Content } = await mug.render();
        return { ...mug, Content };
    }),
);
const bioEntry = (await getCollection("bio"))[0];
const BioContent = bioEntry ? (await bioEntry.render()).Content : null;
const showGrid = false;
---

<Layout title="Sophie Banks | Soapy Creates">
    <main class={`sophie-page is-loading ${showGrid ? "show-grid" : ""}`}>
        {showGrid ? <div class="sophie-grid" aria-hidden="true" /> : null}
        <div class="sophie-mugs">
            {
                mugEntries.map((mug, index) => (
                    <div
                        class="sophie-mug-container"
                        data-index={index}
                        data-title={mug.data.title}
                        data-date={mug.data.date.toLocaleDateString("en-US", {
                            year: "numeric",
                            month: "long",
                            day: "numeric",
                        })}
                        data-image={mug.data.image}
                        data-bg-image={mug.data.bgImage}
                        role="button"
                        tabindex="0"
                    >
                        <div class="sophie-mug-shadow-wrapper" aria-hidden="true">
                            <div class="sophie-mug-shadow sophie-mug-shadow--contact"></div>
                            <img
                                src={mug.data.image}
                                alt=""
                                class="sophie-mug-shadow sophie-mug-shadow--ambient"
                                loading="eager"
                            />
                        </div>
                        <img
                            src={mug.data.image}
                            alt={mug.data.title}
                            class="sophie-mug"
                            loading="eager"
                        />
                    </div>
                ))
            }
        </div>

        <div class="sophie-center">
            <button
                class="sophie-wordmark-button"
                type="button"
                aria-label="Open bio"
            >
                <img
                    src="/soapy wordmark.svg"
                    alt="SOAPY"
                    class="sophie-wordmark"
                    loading="eager"
                />
            </button>
        </div>
        <div class="sophie-chrome">
            <button class="sophie-chrome-tl" type="button">
                Sophie Banks
            </button>
            <p class="sophie-chrome-tr">ARTIST</p>
            <p class="sophie-chrome-bl">Norwich, NORFOLK UK</p>
            <button class="sophie-shuffle" id="shuffle-btn">Shuffle</button>
            <a
                href="https://instagram.com/soapycreates"
                target="_blank"
                rel="noopener"
                class="sophie-chrome-br"
            >
                @SOAPYCREATES
            </a>
        </div>
    </main>

    <!-- Notecard Modal -->
    <div class="notecard-overlay" id="notecard-overlay" aria-hidden="true">
        <div
            class="notecard"
            role="dialog"
            aria-modal="true"
            aria-labelledby="notecard-title"
        >
            <svg
                class="notecard-texture"
                viewBox="0 0 200 200"
                xmlns="http://www.w3.org/2000/svg"
            >
                <filter id="paper-texture">
                    <feTurbulence
                        type="fractalNoise"
                        baseFrequency="0.9"
                        numOctaves="4"
                        result="noise"></feTurbulence>
                    <feDiffuseLighting
                        in="noise"
                        lighting-color="#f5f2eb"
                        surfaceScale="1.5"
                    >
                        <feDistantLight azimuth="45" elevation="60"
                        ></feDistantLight>
                    </feDiffuseLighting>
                </filter>
                <rect width="100%" height="100%" filter="url(#paper-texture)"
                ></rect>
            </svg>
            <div class="notecard-image-container">
                <img class="notecard-image" id="notecard-image" src="" alt="" />
            </div>
            <div class="notecard-content">
                <h2 class="notecard-title" id="notecard-title"></h2>
                <p class="notecard-date" id="notecard-date"></p>
                <div class="notecard-description">
                    <div
                        class="notecard-description-body"
                        id="notecard-description"
                    >
                    </div>
                    <button
                        class="notecard-show-more"
                        id="notecard-show-more"
                        type="button"
                    >
                        Show more
                    </button>
                </div>
            </div>
            <div class="notecard-tape notecard-tape-left"></div>
            <div class="notecard-tape notecard-tape-right"></div>
        </div>
        <span class="notecard-arrow notecard-arrow-prev" aria-label="Previous"
            >&larr;</span
        >
        <span class="notecard-arrow notecard-arrow-next" aria-label="Next"
            >&rarr;</span
        >
    </div>
    <div class="notecard-descriptions" aria-hidden="true">
        {
            mugEntries.map((mug, index) => (
                <div class="notecard-description-source" data-index={index}>
                    <mug.Content />
                </div>
            ))
        }
    </div>
    <div class="bio-overlay" id="bio-overlay" aria-hidden="true">
        <div class="notecard bio-notecard" role="dialog" aria-modal="true">
            <div class="notecard-image-container bio-image-container">
                <img
                    src="/pp-2.png"
                    alt=""
                    class="notecard-image bio-image-back"
                />
                <img
                    src="/pp.png"
                    alt=""
                    class="notecard-image bio-image-front"
                />
            </div>
            <div class="notecard-content">
                <p class="bio-title">Sophie Banks</p>
                <div class="bio-content">
                    {BioContent ? <BioContent /> : null}
                </div>
            </div>
        </div>
    </div>
</Layout>

<script type="module">
    const containers = Array.from(
        document.querySelectorAll(".sophie-mug-container"),
    );

    // Design mode flag (declared early for click handlers)
    let designMode = false;

    // Fixed positions mapped to mug titles (sizes in vw for responsiveness)
    const fixedPositions = {
        "Chunky Mug":    { top: 46.0963, left: 84.1177, size: 40 },
        "Coffee Cup 2":  { top: 70.0637, left: 53.5837, size: 37.5 },
        "Cowboy Mug":    { top: 28.1736, left: 74.0377, size: 43 },
        "Dotty Mug":     { top: 84.4587, left: 79.1232, size: 50 },
        "Flower Cup":    { top: 56.3905, left: 9.5666, size: 50 },
        "Flower Cup 2":  { top: 84.2022, left: 15.4312, size: 50 },
        "Rat Mug":       { top: 10.2781, left: 39.0902, size: 39 },
        "Rocky Mug":     { top: 30.0297, left: 20.6272, size: 37 },
    };

    function applyPositions(animated = false) {
        containers.forEach((container, index) => {
            const title = container.dataset.title;
            const pos = fixedPositions[title];

            if (!pos) {
                console.warn(`No position found for: ${title}`);
                return;
            }

            if (animated) {
                container.style.transition =
                    "top 0.4s ease, left 0.4s ease, width 0.4s ease";
            }
            container.style.top = `${pos.top}%`;
            container.style.left = `${pos.left}%`;
            container.style.width = `${pos.size}vw`;
            if (!animated) {
                container.style.animationDelay = `${0.3 + index * 0.08}s`;
            }
        });
        if (animated) {
            setTimeout(() => {
                containers.forEach((container) => {
                    container.style.transition = "";
                });
                updateShadowPerspective();
            }, 400);
        }
    }

    // Perspective-aware shadows: shadows shift based on mug position
    function updateShadowPerspective() {
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 3; // Light from upper-center
        const maxOffset = 5; // Max shadow shift in pixels

        containers.forEach((container) => {
            const rect = container.getBoundingClientRect();
            const mugX = rect.left + rect.width / 2;
            const mugY = rect.top + rect.height / 2;

            // Shadows shift away from light source
            const offsetX = ((mugX - centerX) / centerX) * maxOffset;
            const offsetY = ((mugY - centerY) / centerY) * maxOffset * 0.5;

            container.style.setProperty('--shadow-offset-x', `${offsetX}px`);
            container.style.setProperty('--shadow-offset-y', `${offsetY}px`);
        });
    }

    applyPositions();
    updateShadowPerspective();

    // Update perspective on resize
    window.addEventListener('resize', () => {
        requestAnimationFrame(updateShadowPerspective);
    });

    // Shuffle button
    const shuffleBtn = document.getElementById("shuffle-btn");
    let danceInterval = null;
    let holdTimeout = null;
    let isDancing = false;

    function startDancing() {
        isDancing = true;
        containers.forEach((container) => {
            container.classList.add("is-dancing");
        });
    }

    function stopDancing() {
        isDancing = false;
        containers.forEach((container) => {
            container.classList.remove("is-dancing");
        });
    }

    // Shuffle disabled - positions are now fixed
    shuffleBtn.style.display = 'none';

    /* Dance easter egg (keep for future use)
    shuffleBtn.addEventListener("mousedown", () => {
        holdTimeout = setTimeout(() => {
            startDancing();
        }, 5000);
    });

    shuffleBtn.addEventListener("mouseup", () => {
        clearTimeout(holdTimeout);
        if (isDancing) {
            stopDancing();
        }
    });

    shuffleBtn.addEventListener("mouseleave", () => {
        clearTimeout(holdTimeout);
        if (isDancing) {
            stopDancing();
        }
    });

    shuffleBtn.addEventListener("touchstart", (e) => {
        e.preventDefault();
        holdTimeout = setTimeout(() => {
            startDancing();
        }, 5000);
    });

    shuffleBtn.addEventListener("touchend", () => {
        clearTimeout(holdTimeout);
        if (isDancing) {
            stopDancing();
        }
    });
    */

    // Wait for all mug images to load before animating in
    const mugImages = Array.from(document.querySelectorAll(".sophie-mug"));
    const imagePromises = mugImages.map((img) => {
        if (img.complete) return Promise.resolve();
        return new Promise((resolve) => {
            img.onload = resolve;
            img.onerror = resolve;
        });
    });

    Promise.all(imagePromises).then(() => {
        requestAnimationFrame(() => {
            const page = document.querySelector(".sophie-page");
            if (page) {
                page.classList.remove("is-loading");
                page.classList.add("is-ready");
            }
        });

        // Preload all bgImages for smooth modal transitions
        containers.forEach((container) => {
            const bgImage = container.dataset.bgImage;
            if (bgImage) {
                const img = new Image();
                img.src = bgImage;
            }
        });
    });

    // Notecard Modal Logic
    const overlay = document.getElementById("notecard-overlay");
    const notecard = overlay.querySelector(".notecard");
    const notecardImage = document.getElementById("notecard-image");
    const notecardTitle = document.getElementById("notecard-title");
    const notecardDate = document.getElementById("notecard-date");
    const notecardDescription = document.getElementById("notecard-description");
    const notecardShowMore = document.getElementById("notecard-show-more");
    const prevArrow = overlay.querySelector(".notecard-arrow-prev");
    const nextArrow = overlay.querySelector(".notecard-arrow-next");
    const descriptionSources = Array.from(
        document.querySelectorAll(".notecard-description-source"),
    );
    const bioOverlay = document.getElementById("bio-overlay");
    const bioCard = bioOverlay?.querySelector(".bio-notecard");
    const bioTriggers = Array.from(
        document.querySelectorAll(
            ".sophie-wordmark-button, .sophie-chrome-tl",
        ),
    );

    let currentIndex = 0;
    let isAnimating = false;

    function updateDescription(index) {
        const source = descriptionSources.find(
            (item) => item.dataset.index === String(index),
        );
        notecardDescription.innerHTML = source ? source.innerHTML : "";
        notecardDescription.classList.remove("is-expanded");
        notecardShowMore.textContent = "Show more";

        requestAnimationFrame(() => {
            const hasOverflow =
                notecardDescription.scrollHeight >
                notecardDescription.clientHeight + 1;
            notecardShowMore.style.display = hasOverflow
                ? "inline-flex"
                : "none";
        });
    }

    function showMug(index, direction = null, fromDrag = false) {
        const container = containers[index];
        const title = container.dataset.title;
        const date = container.dataset.date;
        const bgImage = container.dataset.bgImage;

        if (direction && !isAnimating) {
            isAnimating = true;
            const slideIn =
                direction === "next" ? "slide-in-right" : "slide-in-left";

            if (fromDrag) {
                // Skip slide-out, user already dragged it away
                notecardImage.src = bgImage;
                notecardImage.alt = title;
                notecardTitle.textContent = title;
                notecardDate.textContent = date;
                updateDescription(index);

                notecard.offsetHeight;
                notecard.classList.add(slideIn);

                setTimeout(() => {
                    notecard.classList.remove(slideIn);
                    isAnimating = false;
                }, 280);
            } else {
                // Full animation for arrow/keyboard nav
                const slideOut =
                    direction === "next" ? "slide-out-left" : "slide-out-right";

                notecard.offsetHeight;
                notecard.classList.add(slideOut);

                setTimeout(() => {
                    notecardImage.src = bgImage;
                    notecardImage.alt = title;
                    notecardTitle.textContent = title;
                    notecardDate.textContent = date;
                    updateDescription(index);

                    notecard.classList.remove(slideOut);
                    notecard.offsetHeight;
                    notecard.classList.add(slideIn);

                    setTimeout(() => {
                        notecard.classList.remove(slideIn);
                        isAnimating = false;
                    }, 280);
                }, 220);
            }
        } else {
            notecardImage.src = bgImage;
            notecardImage.alt = title;
            notecardTitle.textContent = title;
            notecardDate.textContent = date;
            updateDescription(index);
        }

        currentIndex = index;
    }

    function openNotecard(container) {
        currentIndex = parseInt(container.dataset.index);
        showMug(currentIndex);
        overlay.classList.add("is-visible");
        overlay.setAttribute("aria-hidden", "false");
    }

    function closeNotecard() {
        overlay.classList.remove("is-visible");
        overlay.setAttribute("aria-hidden", "true");
    }

    function openBio() {
        if (!bioOverlay) return;
        bioOverlay.classList.add("is-visible");
        bioOverlay.setAttribute("aria-hidden", "false");
    }

    function closeBio() {
        if (!bioOverlay) return;
        bioOverlay.classList.remove("is-visible");
        bioOverlay.setAttribute("aria-hidden", "true");
    }

    function goToPrev() {
        if (isAnimating) return;
        const newIndex =
            (currentIndex - 1 + containers.length) % containers.length;
        showMug(newIndex, "prev");
    }

    function goToNext() {
        if (isAnimating) return;
        const newIndex = (currentIndex + 1) % containers.length;
        showMug(newIndex, "next");
    }

    containers.forEach((container) => {
        container.addEventListener("click", () => {
            if (designMode) return;
            openNotecard(container);
        });
        container.addEventListener("keydown", (e) => {
            if (designMode) return;
            if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                openNotecard(container);
            }
        });
    });

    bioTriggers.forEach((trigger) => {
        trigger.addEventListener("click", (e) => {
            e.stopPropagation();
            openBio();
        });
    });

    prevArrow.addEventListener("click", (e) => {
        e.stopPropagation();
        goToPrev();
    });

    nextArrow.addEventListener("click", (e) => {
        e.stopPropagation();
        goToNext();
    });

    notecardShowMore.addEventListener("click", (e) => {
        e.stopPropagation();
        const isExpanded = notecardDescription.classList.toggle("is-expanded");
        notecardShowMore.textContent = isExpanded ? "Show less" : "Show more";
        if (!isExpanded) {
            requestAnimationFrame(() => {
                const hasOverflow =
                    notecardDescription.scrollHeight >
                    notecardDescription.clientHeight + 1;
                notecardShowMore.style.display = hasOverflow
                    ? "inline-flex"
                    : "none";
            });
        } else {
            notecardShowMore.style.display = "inline-flex";
        }
    });

    overlay.addEventListener("click", (e) => {
        if (e.target === overlay) closeNotecard();
    });

    if (bioOverlay && bioCard) {
        bioOverlay.addEventListener("click", (e) => {
            if (e.target === bioOverlay) closeBio();
        });
    }

    document.addEventListener("keydown", (e) => {
        if (!overlay.classList.contains("is-visible")) return;
        if (e.key === "Escape") closeNotecard();
        if (e.key === "ArrowLeft") goToPrev();
        if (e.key === "ArrowRight") goToNext();
    });

    document.addEventListener("keydown", (e) => {
        if (!bioOverlay || !bioOverlay.classList.contains("is-visible")) return;
        if (e.key === "Escape") closeBio();
    });

    // Swipe support for mobile - card follows finger
    let touchStartX = 0;
    let currentTouchX = 0;
    let isSwiping = false;

    notecard.addEventListener(
        "touchstart",
        (e) => {
            if (isAnimating) return;
            touchStartX = e.changedTouches[0].screenX;
            currentTouchX = touchStartX;
            isSwiping = true;
            notecard.style.transition = "none";
        },
        { passive: true },
    );

    notecard.addEventListener(
        "touchmove",
        (e) => {
            if (!isSwiping) return;
            currentTouchX = e.changedTouches[0].screenX;
            const diff = currentTouchX - touchStartX;
            // Move card with finger, with slight resistance
            const resistance = 0.6;
            notecard.style.transform = `translateX(${diff * resistance}px) rotate(${diff * 0.02}deg)`;
        },
        { passive: true },
    );

    notecard.addEventListener(
        "touchend",
        (e) => {
            if (!isSwiping) return;
            isSwiping = false;
            const diff = currentTouchX - touchStartX;
            const threshold = 60;

            if (Math.abs(diff) > threshold) {
                // Swipe left (diff < 0) = next, swipe right (diff > 0) = prev
                const goingNext = diff < 0;
                const newIndex = goingNext
                    ? (currentIndex + 1) % containers.length
                    : (currentIndex - 1 + containers.length) %
                      containers.length;

                // Fly current card off in swipe direction
                const flyOutX = goingNext
                    ? -window.innerWidth
                    : window.innerWidth;
                notecard.style.transition = "transform 0.2s ease-in";
                notecard.style.transform = `translateX(${flyOutX}px)`;

                setTimeout(() => {
                    // Position new card on opposite side
                    const enterFromX = goingNext
                        ? window.innerWidth
                        : -window.innerWidth;
                    notecard.style.transition = "none";
                    notecard.style.transform = `translateX(${enterFromX}px)`;

                    showMug(newIndex, goingNext ? "next" : "prev", true);

                    // Slide new card to center
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            notecard.style.transition =
                                "transform 0.2s ease-out";
                            notecard.style.transform = "translateX(0)";
                        });
                    });
                }, 200);
            } else {
                // Snap back
                notecard.style.transition = "transform 0.2s ease-out";
                notecard.style.transform = "translateX(0)";
            }
        },
        { passive: true },
    );

    // Drag support for desktop
    let isDragging = false;
    let dragStartX = 0;
    let dragCurrentX = 0;
    let hasDragged = false;

    notecard.addEventListener("mousedown", (e) => {
        if (isAnimating) return;
        isDragging = true;
        hasDragged = false;
        dragStartX = e.clientX;
        dragCurrentX = e.clientX;
        notecard.style.cursor = "grabbing";
        notecard.style.transition = "none";
    });

    document.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        dragCurrentX = e.clientX;
        const diff = dragCurrentX - dragStartX;

        if (Math.abs(diff) > 5) hasDragged = true;

        const resistance = 0.6;
        notecard.style.transform = `translateX(${diff * resistance}px) rotate(${diff * 0.02}deg)`;
    });

    document.addEventListener("mouseup", () => {
        if (!isDragging) return;
        isDragging = false;
        notecard.style.cursor = "";

        const diff = dragCurrentX - dragStartX;
        const threshold = 60;

        if (Math.abs(diff) > threshold) {
            // Drag left (diff < 0) = next, drag right (diff > 0) = prev
            const goingNext = diff < 0;
            const newIndex = goingNext
                ? (currentIndex + 1) % containers.length
                : (currentIndex - 1 + containers.length) % containers.length;

            // Fly current card off in drag direction
            const flyOutX = goingNext ? -window.innerWidth : window.innerWidth;
            notecard.style.transition = "transform 0.2s ease-in";
            notecard.style.transform = `translateX(${flyOutX}px)`;

            setTimeout(() => {
                // Position new card on opposite side
                const enterFromX = goingNext
                    ? window.innerWidth
                    : -window.innerWidth;
                notecard.style.transition = "none";
                notecard.style.transform = `translateX(${enterFromX}px)`;

                showMug(newIndex, goingNext ? "next" : "prev", true);

                // Slide new card to center
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        notecard.style.transition = "transform 0.2s ease-out";
                        notecard.style.transform = "translateX(0)";
                    });
                });
            }, 200);
        } else {
            // Snap back
            notecard.style.transition = "transform 0.2s ease-out";
            notecard.style.transform = "translateX(0)";
        }
    });

    // Prevent click after drag
    notecard.addEventListener(
        "click",
        (e) => {
            if (hasDragged) {
                e.stopPropagation();
                hasDragged = false;
            }
        },
        true,
    );

    // ============ DESIGN MODE ============
    let selectedMug = null;
    let designDragStart = { x: 0, y: 0 };
    let mugStartPos = { top: 0, left: 0 };

    // Create toolbar
    const toolbar = document.createElement('div');
    toolbar.id = 'design-toolbar';
    toolbar.innerHTML = `
        <div style="display: flex; gap: 8px; align-items: center;">
            <span style="font-weight: bold;">DESIGN MODE</span>
            <button id="design-log">Log Positions</button>
            <button id="design-reset">Reset</button>
            <button id="design-close">Close</button>
        </div>
        <div id="design-info" style="font-size: 11px; margin-top: 6px;">Click a mug to select, drag to move</div>
    `;
    toolbar.style.cssText = `
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.9);
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-family: monospace;
        font-size: 12px;
        z-index: 9999;
        display: none;
    `;
    document.body.appendChild(toolbar);

    const designInfo = toolbar.querySelector('#design-info');

    function toggleDesignMode() {
        designMode = !designMode;
        toolbar.style.display = designMode ? 'block' : 'none';
        document.body.style.cursor = designMode ? 'crosshair' : '';

        containers.forEach(c => {
            c.style.pointerEvents = designMode ? 'auto' : '';
            c.style.cursor = designMode ? 'grab' : 'pointer';
        });

        if (!designMode && selectedMug) {
            selectedMug.style.outline = '';
            selectedMug = null;
        }
    }

    // Toggle with Cmd/Ctrl + D
    document.addEventListener('keydown', (e) => {
        if ((e.metaKey || e.ctrlKey) && e.key === 'd') {
            e.preventDefault();
            toggleDesignMode();
        }
    });

    // Design mode drag
    containers.forEach((container) => {
        container.addEventListener('mousedown', (e) => {
            if (!designMode) return;
            e.preventDefault();
            e.stopPropagation();

            if (selectedMug) selectedMug.style.outline = '';
            selectedMug = container;
            selectedMug.style.outline = '2px solid #00ff00';
            selectedMug.style.cursor = 'grabbing';

            designDragStart = { x: e.clientX, y: e.clientY };
            mugStartPos = {
                top: parseFloat(container.style.top),
                left: parseFloat(container.style.left)
            };

            const mugsRect = document.querySelector('.sophie-mugs').getBoundingClientRect();

            function onMouseMove(e) {
                const deltaX = e.clientX - designDragStart.x;
                const deltaY = e.clientY - designDragStart.y;

                const newLeft = mugStartPos.left + (deltaX / mugsRect.width) * 100;
                const newTop = mugStartPos.top + (deltaY / mugsRect.height) * 100;

                container.style.left = `${newLeft}%`;
                container.style.top = `${newTop}%`;

                designInfo.textContent = `${container.dataset.title}: top: ${newTop.toFixed(2)}%, left: ${newLeft.toFixed(2)}%, size: ${parseFloat(container.style.width).toFixed(1)}vw`;
            }

            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                if (selectedMug) selectedMug.style.cursor = 'grab';
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
    });

    // Resize selected mug with scroll (uses vw units)
    document.addEventListener('wheel', (e) => {
        if (!designMode || !selectedMug) return;
        e.preventDefault();
        const currentSize = parseFloat(selectedMug.style.width);
        const delta = e.deltaY > 0 ? -1 : 1;
        const newSize = Math.max(10, Math.min(50, currentSize + delta));
        selectedMug.style.width = `${newSize}vw`;
        designInfo.textContent = `${selectedMug.dataset.title}: size: ${newSize}vw`;
    }, { passive: false });

    // Toolbar buttons
    toolbar.querySelector('#design-log').addEventListener('click', () => {
        const positions = containers.map(c => ({
            title: c.dataset.title,
            top: parseFloat(c.style.top),
            left: parseFloat(c.style.left),
            size: parseFloat(c.style.width)
        }));
        console.log('Mug Positions:', JSON.stringify(positions, null, 2));

        // Also log in code-ready format
        console.log('\n// Code-ready format:');
        console.log('const fixedPositions = {');
        positions.forEach(p => {
            console.log(`    "${p.title}": { top: ${p.top}, left: ${p.left}, size: ${p.size} },`);
        });
        console.log('};');

        alert('Positions logged to console!');
    });

    toolbar.querySelector('#design-reset').addEventListener('click', () => {
        applyPositions(true);
        updateShadowPerspective();
    });

    toolbar.querySelector('#design-close').addEventListener('click', toggleDesignMode);
</script>
