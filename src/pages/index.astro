---
import Layout from '../layouts/Layout.astro';
import { getCollection } from 'astro:content';
import '../styles/ceramicist.css';

const mugs = (await getCollection('mugs')).sort(
	(a, b) => a.data.date.valueOf() - b.data.date.valueOf()
);
const showGrid = !import.meta.env.PROD;
---

<Layout title="Sophie Banks | Soapy Creates">
	<main class={`ceramicist-page is-loading ${showGrid ? 'show-grid' : ''}`}>
		{showGrid ? <div class="ceramicist-grid" aria-hidden="true"></div> : null}
		<div class="ceramicist-mugs">
			{mugs.map((mug, index) => (
				<div
					class="ceramicist-mug-container"
					data-index={index}
					data-title={mug.data.title}
					data-date={mug.data.date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}
					data-image={mug.data.image}
					data-bg-image={mug.data.bgImage}
					role="button"
					tabindex="0"
				>
					<img src={mug.data.image} alt="" class="ceramicist-mug-shadow-img" loading="eager" aria-hidden="true" />
					<img src={mug.data.image} alt={mug.data.title} class="ceramicist-mug" loading="eager" />
				</div>
			))}
		</div>

		<div class="ceramicist-center">
			<img
				src="/soapy wordmark.svg"
				alt="SOAPY"
				class="ceramicist-wordmark"
				loading="eager"
			/>
			<p class="ceramicist-subtitle">artist</p>
		</div>
	</main>

	<!-- Notecard Modal -->
	<div class="notecard-overlay" id="notecard-overlay" aria-hidden="true">
		<div class="notecard" role="dialog" aria-modal="true" aria-labelledby="notecard-title">
			<svg class="notecard-texture" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
				<filter id="paper-texture">
					<feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" result="noise" />
					<feDiffuseLighting in="noise" lighting-color="#f5f2eb" surfaceScale="1.5">
						<feDistantLight azimuth="45" elevation="60" />
					</feDiffuseLighting>
				</filter>
				<rect width="100%" height="100%" filter="url(#paper-texture)" />
			</svg>
			<div class="notecard-image-container">
				<img class="notecard-image" id="notecard-image" src="" alt="" />
			</div>
			<div class="notecard-content">
				<h2 class="notecard-title" id="notecard-title"></h2>
				<p class="notecard-date" id="notecard-date"></p>
			</div>
			<div class="notecard-tape notecard-tape-left"></div>
			<div class="notecard-tape notecard-tape-right"></div>
		</div>
		<span class="notecard-arrow notecard-arrow-prev" aria-label="Previous">&larr;</span>
		<span class="notecard-arrow notecard-arrow-next" aria-label="Next">&rarr;</span>
	</div>
</Layout>

<script type="module">
	const containers = Array.from(
		document.querySelectorAll('.ceramicist-mug-container')
	);

	function generatePositions(count) {
		const isMobile = window.innerWidth <= 768;

		// Define zones around the center wordmark
		// Each zone has: top range, left range, and max mugs allowed
		const zones = isMobile ? [
			// Mobile: stack vertically with mugs on sides
			{ top: [3, 20], left: [5, 35], max: 2 },    // Top left
			{ top: [3, 20], left: [65, 95], max: 2 },   // Top right
			{ top: [25, 40], left: [3, 25], max: 1 },   // Mid-upper left
			{ top: [25, 40], left: [75, 97], max: 1 },  // Mid-upper right
			{ top: [60, 75], left: [3, 25], max: 1 },   // Mid-lower left
			{ top: [60, 75], left: [75, 97], max: 1 },  // Mid-lower right
			{ top: [78, 95], left: [5, 35], max: 2 },   // Bottom left
			{ top: [78, 95], left: [65, 95], max: 2 },  // Bottom right
		] : [
			// Desktop: spread around center
			{ top: [5, 22], left: [3, 22], max: 2 },    // Top left corner
			{ top: [5, 22], left: [28, 48], max: 1 },   // Top left-center
			{ top: [5, 22], left: [52, 72], max: 1 },   // Top right-center
			{ top: [5, 22], left: [78, 97], max: 2 },   // Top right corner
			{ top: [30, 50], left: [3, 18], max: 1 },   // Middle left upper
			{ top: [50, 70], left: [3, 18], max: 1 },   // Middle left lower
			{ top: [30, 50], left: [82, 97], max: 1 },  // Middle right upper
			{ top: [50, 70], left: [82, 97], max: 1 },  // Middle right lower
			{ top: [78, 95], left: [3, 22], max: 2 },   // Bottom left corner
			{ top: [78, 95], left: [28, 48], max: 1 },  // Bottom left-center
			{ top: [78, 95], left: [52, 72], max: 1 },  // Bottom right-center
			{ top: [78, 95], left: [78, 97], max: 2 },  // Bottom right corner
		];

		// Track how many mugs placed in each zone
		const zoneCounts = zones.map(() => 0);
		const positions = [];

		// Size range
		const minSize = isMobile ? 145 : 170;
		const sizeRange = isMobile ? 40 : 55;

		for (let i = 0; i < count; i++) {
			// Find zones that aren't full, preferring emptier ones
			const availableZones = zones
				.map((zone, idx) => ({ zone, idx, count: zoneCounts[idx] }))
				.filter(({ zone, count }) => count < zone.max)
				.sort((a, b) => a.count - b.count);

			if (availableZones.length === 0) {
				// All zones full, cycle through
				const idx = i % zones.length;
				availableZones.push({ zone: zones[idx], idx, count: zoneCounts[idx] });
			}

			// Pick from least-filled zones with some randomness
			const leastFilled = availableZones.filter(z => z.count === availableZones[0].count);
			const { zone, idx } = leastFilled[Math.floor(Math.random() * leastFilled.length)];
			zoneCounts[idx]++;

			// Random position within zone with slight jitter
			const top = zone.top[0] + Math.random() * (zone.top[1] - zone.top[0]);
			const left = zone.left[0] + Math.random() * (zone.left[1] - zone.left[0]);
			const size = minSize + Math.random() * sizeRange;

			positions.push({ top, left, size });
		}

		// Shuffle positions so same zones don't always animate together
		return positions.sort(() => Math.random() - 0.5);
	}

	const positions = generatePositions(containers.length);
	containers.forEach((container, index) => {
		const { top, left, size } = positions[index];
		container.style.top = `${top}%`;
		container.style.left = `${left}%`;
		container.style.width = `${size}px`;
		container.style.animationDelay = `${0.3 + index * 0.08}s`;
	});

	// Wait for all mug images to load before animating in
	const mugImages = Array.from(document.querySelectorAll('.ceramicist-mug'));
	const imagePromises = mugImages.map((img) => {
		if (img.complete) return Promise.resolve();
		return new Promise((resolve) => {
			img.onload = resolve;
			img.onerror = resolve;
		});
	});

	Promise.all(imagePromises).then(() => {
		requestAnimationFrame(() => {
			const page = document.querySelector('.ceramicist-page');
			if (page) {
				page.classList.remove('is-loading');
				page.classList.add('is-ready');
			}
		});
	});

	// Notecard Modal Logic
	const overlay = document.getElementById('notecard-overlay');
	const notecard = overlay.querySelector('.notecard');
	const notecardImage = document.getElementById('notecard-image');
	const notecardTitle = document.getElementById('notecard-title');
	const notecardDate = document.getElementById('notecard-date');
	const prevArrow = overlay.querySelector('.notecard-arrow-prev');
	const nextArrow = overlay.querySelector('.notecard-arrow-next');

	let currentIndex = 0;
	let isAnimating = false;

	function showMug(index, direction = null, fromDrag = false) {
		const container = containers[index];
		const title = container.dataset.title;
		const date = container.dataset.date;
		const bgImage = container.dataset.bgImage;

		if (direction && !isAnimating) {
			isAnimating = true;
			const slideIn = direction === 'next' ? 'slide-in-right' : 'slide-in-left';

			if (fromDrag) {
				// Skip slide-out, user already dragged it away
				notecardImage.src = bgImage;
				notecardImage.alt = title;
				notecardTitle.textContent = title;
				notecardDate.textContent = date;

				notecard.offsetHeight;
				notecard.classList.add(slideIn);

				setTimeout(() => {
					notecard.classList.remove(slideIn);
					isAnimating = false;
				}, 280);
			} else {
				// Full animation for arrow/keyboard nav
				const slideOut = direction === 'next' ? 'slide-out-left' : 'slide-out-right';

				notecard.offsetHeight;
				notecard.classList.add(slideOut);

				setTimeout(() => {
					notecardImage.src = bgImage;
					notecardImage.alt = title;
					notecardTitle.textContent = title;
					notecardDate.textContent = date;

					notecard.classList.remove(slideOut);
					notecard.offsetHeight;
					notecard.classList.add(slideIn);

					setTimeout(() => {
						notecard.classList.remove(slideIn);
						isAnimating = false;
					}, 280);
				}, 220);
			}
		} else {
			notecardImage.src = bgImage;
			notecardImage.alt = title;
			notecardTitle.textContent = title;
			notecardDate.textContent = date;
		}

		currentIndex = index;
	}

	function openNotecard(container) {
		currentIndex = parseInt(container.dataset.index);
		showMug(currentIndex);
		overlay.classList.add('is-visible');
		overlay.setAttribute('aria-hidden', 'false');
	}

	function closeNotecard() {
		overlay.classList.remove('is-visible');
		overlay.setAttribute('aria-hidden', 'true');
	}

	function goToPrev() {
		if (isAnimating) return;
		const newIndex = (currentIndex - 1 + containers.length) % containers.length;
		showMug(newIndex, 'prev');
	}

	function goToNext() {
		if (isAnimating) return;
		const newIndex = (currentIndex + 1) % containers.length;
		showMug(newIndex, 'next');
	}

	containers.forEach((container) => {
		container.addEventListener('click', () => openNotecard(container));
		container.addEventListener('keydown', (e) => {
			if (e.key === 'Enter' || e.key === ' ') {
				e.preventDefault();
				openNotecard(container);
			}
		});
	});

	prevArrow.addEventListener('click', (e) => {
		e.stopPropagation();
		goToPrev();
	});

	nextArrow.addEventListener('click', (e) => {
		e.stopPropagation();
		goToNext();
	});

	overlay.addEventListener('click', (e) => {
		if (e.target === overlay) closeNotecard();
	});

	document.addEventListener('keydown', (e) => {
		if (!overlay.classList.contains('is-visible')) return;
		if (e.key === 'Escape') closeNotecard();
		if (e.key === 'ArrowLeft') goToPrev();
		if (e.key === 'ArrowRight') goToNext();
	});

	// Swipe support for mobile
	let touchStartX = 0;
	let touchEndX = 0;

	notecard.addEventListener('touchstart', (e) => {
		touchStartX = e.changedTouches[0].screenX;
	}, { passive: true });

	notecard.addEventListener('touchend', (e) => {
		touchEndX = e.changedTouches[0].screenX;
		const diff = touchStartX - touchEndX;
		if (Math.abs(diff) > 50) {
			if (diff > 0) {
				const newIndex = (currentIndex + 1) % containers.length;
				showMug(newIndex, 'next', true);
			} else {
				const newIndex = (currentIndex - 1 + containers.length) % containers.length;
				showMug(newIndex, 'prev', true);
			}
		}
	}, { passive: true });

	// Drag support for desktop
	let isDragging = false;
	let dragStartX = 0;
	let dragCurrentX = 0;
	let hasDragged = false;

	notecard.addEventListener('mousedown', (e) => {
		if (isAnimating) return;
		isDragging = true;
		hasDragged = false;
		dragStartX = e.clientX;
		dragCurrentX = e.clientX;
		notecard.style.cursor = 'grabbing';
		notecard.style.transition = 'none';
	});

	document.addEventListener('mousemove', (e) => {
		if (!isDragging) return;
		dragCurrentX = e.clientX;
		const diff = dragCurrentX - dragStartX;

		if (Math.abs(diff) > 5) hasDragged = true;

		const rotation = diff * 0.05;
		const clampedRotation = Math.max(-10, Math.min(10, rotation));
		notecard.style.transform = `perspective(800px) translateX(${diff * 0.4}px) rotateY(${clampedRotation}deg) rotateZ(${-1 + diff * 0.02}deg)`;
		notecard.style.opacity = 1 - Math.abs(diff) * 0.002;
	});

	document.addEventListener('mouseup', () => {
		if (!isDragging) return;
		isDragging = false;
		notecard.style.cursor = '';
		notecard.style.transition = '';
		notecard.style.transform = '';
		notecard.style.opacity = '';

		const diff = dragStartX - dragCurrentX;
		if (Math.abs(diff) > 60) {
			if (diff > 0) {
				const newIndex = (currentIndex + 1) % containers.length;
				showMug(newIndex, 'next', true);
			} else {
				const newIndex = (currentIndex - 1 + containers.length) % containers.length;
				showMug(newIndex, 'prev', true);
			}
		}
	});

	// Prevent click after drag
	notecard.addEventListener('click', (e) => {
		if (hasDragged) {
			e.stopPropagation();
			hasDragged = false;
		}
	}, true);
</script>
